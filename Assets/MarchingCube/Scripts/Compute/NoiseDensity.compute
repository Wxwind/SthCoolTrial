#pragma kernel NoiseDensity
#include "./SimplexNoise.compute"

static const int numThreads = 8;
//Noise Data
RWStructuredBuffer<float4> points;
int numPointsPerAxis;
float chunkSize;
float3 center;
float3 offset;
float voxelSize;
float3 worldSize;

int indexFromCoord(int x, int y, int z) {
    return z * numPointsPerAxis * numPointsPerAxis + y * numPointsPerAxis + x;
}

// Noise FBM settings
StructuredBuffer<float3> offsets;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
bool closeEdges;
float hardFloor;
float hardFloorWeight;
float4 params;

//以voxel为单位调用NoiseDensity
//为每个voxel的顶点生成isoLevel
[numthreads(numThreads,numThreads,numThreads)]
void NoiseDensity (int3 id : SV_DispatchThreadID)
{
    //可能线程开多了所以需要越界判断
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis) {
        return;
    }

    //id(0,0,0)对应xyz最小处的顶点
    float3 pos = center + id * voxelSize - chunkSize/2;

    float noise = 0;

    float frequency = noiseScale/100;
    float amplitude = 1;
    float weight = 1;
    //fbm(不同频率振幅的波叠加)
    for (int j =0; j < octaves; j ++) {
        float n = simpelxNoise(pos * frequency + offsets[j] + offset);
        float v = 1-abs(n);
        v = v*v;
        v *= weight;
        weight = max(min(v*weightMultiplier,1),0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    float finalVal = -(pos.y + floorOffset) + noise * noiseWeight + (pos.y%params.x) * params.y;

    if (pos.y < hardFloor) {
        finalVal += hardFloorWeight;
    }

    if (closeEdges) {
        float3 edgeOffset = abs(pos*2)-worldSize + voxelSize/2;
        float edgeWeight = saturate(sign(max(max(edgeOffset.x,edgeOffset.y),edgeOffset.z)));
        finalVal = finalVal * (1-edgeWeight) - 100 * edgeWeight;
        
    }

    int index = indexFromCoord(id.x,id.y,id.z);
    points[index] = float4(pos, finalVal);
}